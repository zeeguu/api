#!/usr/bin/env python3
"""
Audio-Engleza: Audio generator from script files

This tool reads a lesson script file and generates the audio file.
Use after editing scripts generated by generate_script.py

Usage:
    python generate_audio.py --script scripts/to_have.txt --lesson-id 1
"""

import sys
import os
import argparse
import shutil
import json
import re
from datetime import datetime
from zeeguu.api.app import create_app
from zeeguu.core.audio_lessons.voice_synthesizer import VoiceSynthesizer

# Configuration
WEBSITE_DIR = "/Users/gh/zeeguu/audio-engleza.github.io"
AUDIO_DIR = os.path.join(WEBSITE_DIR, "audio")
LESSON_INDEX_FILE = os.path.join(WEBSITE_DIR, "lessons.json")

def parse_script_file(script_file):
    """Parse script file to extract metadata and script content"""
    
    if not os.path.exists(script_file):
        raise FileNotFoundError(f"Script file not found: {script_file}")
    
    with open(script_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Extract metadata from header
    english_phrase = None
    romanian_translation = None
    
    for line in content.split('\n'):
        if line.startswith('# English:'):
            english_phrase = line.replace('# English:', '').strip()
        elif line.startswith('# Romanian:'):
            romanian_translation = line.replace('# Romanian:', '').strip()
    
    # Extract script content (everything after the separator)
    if "# ========================================" in content:
        script_content = content.split("# ========================================")[1].strip()
    else:
        # Fallback: remove comment lines
        lines = content.split('\n')
        script_lines = [line for line in lines if not line.strip().startswith('#')]
        script_content = '\n'.join(script_lines).strip()
    
    return english_phrase, romanian_translation, script_content

def create_semantic_filename(english_phrase, lesson_id):
    """Create a semantic filename from the English phrase"""
    semantic_name = re.sub(r'[^a-zA-Z0-9\s]', '', english_phrase.lower())
    semantic_name = re.sub(r'\s+', '_', semantic_name.strip())
    return f"{semantic_name}_{lesson_id}.mp3"

def get_next_lesson_id():
    """Get the next available lesson ID"""
    index_data = load_lesson_index()
    if not index_data["lessons"]:
        return 1
    
    # Get the highest existing ID and add 1
    max_id = max(lesson["id"] for lesson in index_data["lessons"])
    return max_id + 1

def load_lesson_index():
    """Load the existing lesson index"""
    if os.path.exists(LESSON_INDEX_FILE):
        with open(LESSON_INDEX_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    else:
        return {"lessons": [], "last_updated": "", "total_count": 0}

def save_lesson_index(index_data):
    """Save the lesson index"""
    with open(LESSON_INDEX_FILE, 'w', encoding='utf-8') as f:
        json.dump(index_data, f, indent=2, ensure_ascii=False)

def add_lesson_to_index(lesson_id, english_phrase, romanian_translation, filename):
    """Add or update lesson in the index"""
    index_data = load_lesson_index()
    
    # Remove existing lesson with same ID (overwrite)
    index_data["lessons"] = [l for l in index_data["lessons"] if l["id"] != lesson_id]
    
    # Add new lesson
    lesson_entry = {
        "id": lesson_id,
        "english": english_phrase,
        "romanian": romanian_translation,
        "filename": filename,
        "created_at": datetime.now().isoformat()
    }
    
    index_data["lessons"].append(lesson_entry)
    index_data["lessons"].sort(key=lambda x: x["id"])  # Sort by ID
    index_data["last_updated"] = datetime.now().isoformat()
    index_data["total_count"] = len(index_data["lessons"])
    
    save_lesson_index(index_data)
    return lesson_entry

def generate_audio_from_script(script_file, lesson_id=None):
    """Generate audio from script file"""
    
    # Parse script file
    english_phrase, romanian_translation, script_content = parse_script_file(script_file)
    
    if not english_phrase or not romanian_translation:
        raise ValueError("Could not extract English phrase and Romanian translation from script file")
    
    # Auto-assign lesson ID if not provided
    if lesson_id is None:
        lesson_id = get_next_lesson_id()
        print(f"Auto-assigned lesson ID: {lesson_id}")
    
    print(f"English: {english_phrase}")
    print(f"Romanian: {romanian_translation}")
    print(f"Script length: {len(script_content)} characters")
    
    # Generate audio
    app = create_app()
    with app.app_context():
        print("\\nGenerating TTS audio...")
        voice_synthesizer = VoiceSynthesizer()
        
        mp3_path = voice_synthesizer.generate_lesson_audio(
            audio_lesson_meaning_id=lesson_id,
            script=script_content,
            language_code="en-US",
            teacher_language="ro-RO"
        )
        
        print(f"Audio generated: {mp3_path}")
        
        # Deploy to website
        print("\\nDeploying to website...")
        os.makedirs(AUDIO_DIR, exist_ok=True)
        
        filename = create_semantic_filename(english_phrase, lesson_id)
        dest_path = os.path.join(AUDIO_DIR, filename)
        shutil.copy2(mp3_path, dest_path)
        
        website_filename = f"audio/{filename}"
        
        # Update index
        print("Updating lesson index...")
        lesson_entry = add_lesson_to_index(lesson_id, english_phrase, romanian_translation, website_filename)
        
        return dest_path, lesson_entry

def main():
    parser = argparse.ArgumentParser(description='Generate audio from lesson script files')
    parser.add_argument('--script', '-s', required=True, help='Path to script file')
    parser.add_argument('--lesson-id', '-id', type=int, help='Lesson ID number (auto-assigned if not provided)')
    
    args = parser.parse_args()
    
    print("\\n" + "="*60)
    print("AUDIO-ENGLEZA: Audio Generator")
    print("From edited script files")
    print("="*60)
    
    try:
        audio_path, lesson_entry = generate_audio_from_script(args.script, args.lesson_id)
        
        print("\\n" + "="*60)
        print("SUCCESS!")
        print("="*60)
        print(f"Audio lesson generated successfully!")
        print(f"\\nLesson details:")
        print(f"  - Lesson ID: {lesson_entry['id']}")
        print(f"  - English phrase: {lesson_entry['english']}")
        print(f"  - Romanian translation: {lesson_entry['romanian']}")
        print(f"  - Audio file: {lesson_entry['filename']}")
        print(f"  - Local path: {audio_path}")
        print(f"\\nðŸŽ¯ Next step: python deploy_lessons.py --generate-html")
        
    except Exception as e:
        print(f"\\nError: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()